---
title: 页面置换算法
date: 2018-09-05 21:10:49
tags: 操作系统
---



全文整理自 [大厂面试爱问的“调度算法”，20 张图一举拿下](https://mp.weixin.qq.com/s/ZifCDDU-zdUa7fOFo7epiw), 版权归原作者所有



<br>


> 在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须选择内存中的一个页面将其移出，以便为即将调入内存的页面让出空间。而用来选择淘汰哪一个页面的规则就叫做页面置换算法。



<br>



### 缺页异常（缺页中断）

<br>

在了解内存页面置换算法前，需先懂得 *缺页异常（缺页中断）*。

当 CPU 访问的页面不在物理内存时，便会产生一个*缺页中断*，请求操作系统将所缺页调入到物理内存。


<br>

其与一般中断的主要区别在于：

- 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。

- 缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。


<br>


缺页中断的处理流程，如下图：

<img src="页面置换算法/1.png" width = 100% height = 50% />

<br>


**缺页中断的处理流程:**

1. 在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。

2. 如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。

3. 操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。

4. 找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。

5. 页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。

6. 最后，CPU 重新执行导致缺页异常的指令。

<br>

上面所说的过程，第 4 步是能在物理内存找到空闲页的情况，那如果找不到呢？


找不到空闲页的话，则说明此时内存已满了，这时，就需要 **「页面置换算法」** 选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。

<br>

页表项通常有如下图的字段：

<img src="页面置换算法/2.png" width = 100% height = 50% />

其中：

- 状态位：用于表示该页是否有效，也就是说是否在物理内存中，供程序访问时参考。

- 访问字段：用于记录该页在一段时间被访问的次数，供页面置换算法选择出页面时参考。

- 修改位：表示该页在调入内存后是否有被修改过，由于内存中的每一页都在磁盘上保留一份副本，因此，如果没有修改，在置换该页时就不需要将该页写回到磁盘上，以减少系统的开销；如果已经被修改，则将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本。

- 硬盘地址：用于指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用。

如下是虚拟内存的管理整个流程，可从下面这张图看到：

<img src="页面置换算法/3.png" width = 100% height = 50% />


所以，**页面置换算法** 的功能是: 当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页。

<br>

那其算法目标则是，**尽可能减少页面的换入换出的次数**，常见的页面置换算法有如下几种：

<br>

- 最佳页面置换算法（OPT）

- 先进先出置换算法（FIFO）

- 最近最久未使用置换算法（LRU）

- 时钟页面置换算法（Clock）

- 最不常用置换算法（LFU）


<br>

---



<br>

### 最佳置换算法（OPT）

<br>

*最佳页面置换算法* 基本思路是，**置换在「未来」最长时间不访问的页面。**



故而，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。

举例如下:

假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：

<img src="页面置换算法/4.png" width = 100% height = 50% />


在这个请求的页面序列中，缺页共发生了 `7` 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 `4` 次。

这很理想，但在实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。

所以，最佳页面置换算法作用是为了衡量算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。


<br>

---



<br>

### 先进先出置换算法（FIFO）

<br>

既然无法预知页面在下一次访问前所需的等待时间，那可以**选择在内存驻留时间很长的页面中进行置换**，这就是「先进先出置换」算法的思想。

还是以前面 请求页面序列作为例子，假设使用 先进先出置换算法，则过程如下图：

<img src="页面置换算法/5.png" width = 100% height = 50% />


在这个请求的页面序列中，缺页共发生了 `10` 次，页面置换共发生了 `7`5
 次，跟最佳页面置换算法比较起来，性能明显差了很多。

<br>

---



<br>

### 最近最久未使用置换算法（LRU）


<br>


最近最久未使用（LRU）的置换算法的基本思路是，发生缺页时，**选择最长时间没有被访问的页面进行置换**，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用(*局部性原理*)。

这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。

还是以前面请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：


<img src="页面置换算法/6.png" width = 100% height = 50% />



在这个请求的页面序列中，缺页共发生了 `9` 次，页面置换共发生了 `6` 次，跟先进先出置换算法比较起来，性能提高了一些。

虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。

困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头，是一个非常费时的操作。

所以，LRU 虽然看上去不错，但由于开销较大，实际比较少使用。



<br>

---



<br>

### 时钟页面置换算法（Clock）


<br>



那有没有一种既能优化置换的次数，也能方便实现的算法呢？

*时钟页面置换算法* 就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。

该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针指向的页面：

如果它的访问位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；

如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；

如下是一副时钟页面置换算法的工作流程图，可在下方看到：

<img src="页面置换算法/7.png" width = 100% height = 50% />



了解了这个算法的工作方式，就明白为什么被称为时钟（Clock）算法了。




<br>

---



<br>

### 最不常用置换算法（LFU）


<br>

最不常用（LFU）算法，它的意思不是指这个算法不常用，而是当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。

其实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。

看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，需要考虑效率和硬件成本。

要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。

且还有一个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。

那这个问题的解决办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。



<br>




---


<br>

参考:


[操作系统中的算法/策略](https://dashen.tech/2021/02/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E7%AD%96%E7%95%A5/)

[Linux内核分析与应用4-内存管理](https://dashen.tech/2020/05/17/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A84-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)


[操作系统考点总结](https://blog.csdn.net/weixin_43823808/article/details/108254765)


[「页面置换算法」五大盘点](https://mp.weixin.qq.com/s/ZifCDDU-zdUa7fOFo7epiw)

[操作系统之页面置换算法](https://www.cnblogs.com/fkissx/p/4712959.html)