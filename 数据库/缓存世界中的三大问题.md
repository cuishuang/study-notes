---
title: 缓存世界中的三大问题
date: 2017-09-14 22:19:12
tags: 数据库
---


### 缓存穿透 (Cache Penetration)

<br>

> 穿透形象一点就是：请求过来了 转了一圈 一无所获 就像穿过透明地带一样



用户查询数据库，返回的结果为空(未查到数据),并且结果不会在缓存中存储。

假设用户不断发起这样的请求，它将永远不会访问缓存，导致所有查询都落在数据库上，从而导致数据库被打死。


<br>

解决方案：

- 1） 通过用户认证、参数验证等，在上层拦截这些不合理的请求；

- 2） 当数据库查询结果为空时，数据也被缓存，但缓存有效期设置较短，以免影响正常数据的缓存。

- 3) 另外一种思路，转换为查找问题，类似于在海量数据中查找某个key是否存在，考虑空间复杂度和时间复杂度，一般选用布隆过滤器来实现

<br>


### 缓存击穿 (Hotspot Invalid)


<br>

> 英文名即 “热点失效”

当热点数据存储到期时，多个线程同时请求热点数据。因为缓存刚过期，所有并发请求都会到数据库查询数据。


<br>

解决方案：

实际上，在大多数实际业务场景中，缓存击穿是实时发生的，但不会对数据库造成太大压力，因为一般的公司业务，并发量不会那么高。当然如果你不幸有这种情况，可以通过设置这些热点键，使其永远不会过期。

另一种方法是通过互斥锁来控制查询数据库的线程访问，但这种会导致系统的吞吐率下降，需要实际情况使用。

(golang扩展原语包里有 singleflight方法，参见[SingleFlight-抑制对下游多次重复请求,防止缓存击穿的利器](https://dashen.tech/2020/10/15/SingleFlight-%E6%8A%91%E5%88%B6%E5%AF%B9%E4%B8%8B%E6%B8%B8%E5%A4%9A%E6%AC%A1%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82-%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%9A%84%E5%88%A9%E5%99%A8/))



<br>


### 缓存雪崩（Cache Avalanche）

<br>

> Avalanche: n/v. 雪崩

数据未加载到缓存中，或者缓存同时大范围失效，导致所有请求都请求到数据库，导致数据库、CPU 和内存过载，甚至停机。

一个简单的雪崩过程：

1） Redis 集群的大面积故障；

2） 缓存失败，但仍有大量请求访问缓存服务 Redis；

3） 在大量 Redis 请求失败后，请求转向数据库；

4） 数据库请求急剧增加，导致数据库被打死；

5） 由于应用程序服务大部分都依赖于数据库和 Redis 服务，它很快就会导致服务器集群的雪崩，最后整个系统将彻底崩溃。


<br>

解决方案：


**事前：高可用的缓存**

高可用的缓存是防止出现整个缓存故障。即使个别节点，机器甚甚至机房都关闭，系统仍然可以提供服务，`Redis 哨兵(Sentinel)` 和 `Redis 集群(Cluster)` 都可以做到高可用。


**事中：缓存降级（临时支持**

当访问次数急剧增加导致服务出现问题时，我们如何确保服务仍然可用?在国内使用比较多的是 Hystrix，它通过`熔断、降级、限流`三个手段来降低雪崩发生后的损失。只要确保数据库不挂，系统总可以响应请求，


**事后：Redis 备份和快速预热**

1） Redis 数据备份和恢复

2） 快速缓存预热


<br>


---


<br>

参考：

[缓存世界中的三大问题及解决方案](https://zhuanlan.zhihu.com/p/77492338)

[缓存雪崩 Cache Avalanche / 缓存穿透 Cache Penetration / 缓存击穿 Hotspot Invalid](https://www.cnblogs.com/Leo_wl/p/12294093.html)