---
title: 经典问题--超大字符串型整数乘除
date: 2019-02-15 10:08:10
tags: 算法
---

[之前](https://dashen.tech/2019/02/13/%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98-%E8%B6%85%E5%A4%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B%E6%95%B4%E6%95%B0%E5%8A%A0%E5%87%8F/)留了坑,关于超大字符串型整数乘除的问题
还是以加减一文中的a1和a2为例(假设π小数点后50位乘以$10^{50}$的值为a1,e小数点后30位乘以$10^{30}$的值为a2),计算a1xa2,以及a1/a2的值


- 分析,两个数x,y相乘,即(y的个位乘以x) + (y的十位乘以x)乘以10 + ... + (y的最高位乘以x)乘以最高位 之和~
- 如以1035x287为例,即7x1035 + 8x1035x10 + 2x1035x100,即乘法分配律的变形,1035x(7+80+200)=1035x287

- //两个数相乘,积的长度不会超过两个数长度之和,如9999x9999=99980001

- 一个核心点,确定好结果多长有几个坑,想办法设计算法,往坑位写入正确的内容

```go

func main(){
	str1 := "314159265358979323846264338327950288419716939937510"
	str2 :=                     "2718281828459045235360287471352"
	rs := multiply(str1,str2)
	fmt.Println(rs)
}


func multiply(str1, str2 string) string {
	l1, l2 := len(str1), len(str2)
	l := l1 + l2
	num := make([]int, l)

	for i := 0; i < l1; {

		for j := 0; j < l2; {
			num[l-i-j-1] += int(str1[l1-1-i]-'0') * int(str2[l2-1-j]-'0')
			j = j + 1
		}

		i = i + 1
	}
	//上面这段循环是核心,下面和大数加减大致都一样了~


	//从最右往左边,处理进位
	for n := l; n > 1; {
		temp := num[n-1]
		num[n-1] = num[n-1] % 10 //如35/10,得5
		num[n-2] += temp / 10    //如35/10,得3,将3加到上一位
		n = n - 1
	}

	//汇总字符串结果
	res := ""

	for _, i := range num {
		s := strconv.Itoa(i)
		res += s
	}

	//去除开头可能存在的0
	if len(res) > 1 {
		res = strings.TrimLeft(res, "0")
	}

	return res
}


```

  
   运行结果:
   
   ```
    853973422267356706546355086954449319694770135199398255015274067614534738795213520

   ```
   
   
   [戳此查看更多有趣的入门算法问题](https://blog.csdn.net/qq_36183935/article/details/80735192)

   [Golang实现大数乘法](https://blog.cyeam.com/golang/2014/08/15/go_largenumberx)