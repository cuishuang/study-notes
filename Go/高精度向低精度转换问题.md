---
title: 高精度向低精度转换问题
date: 2019-04-29 21:34:58
tags: Go
---

<br>

- 高精度向低精度转换，在计算机中会从最低位开始截取直到截取满低精度的精度范围为止;

```go
func main(){
    c := int16(2000)
    fmt.Println(int8(c))
}
```

结果为:
```result
-48
```

#### Why is -48 ?


- int16范围为16个比特位所能表征的数量,即占两个字节;转换为二进制为 `0000 0111 1101 0000`;
- 类似的,int8占一个字节,只能表示8个比特位所能表征的数量;从高向低转换时,从右向左截取,即 `1101 0000`

> 带符号整数有原码、反码、补码等几种编码方式。原码即直接将真值转换为其相应的二进制形式，而反码和补码是对原码进行某种转换编码方式。正整数的原码、反码和补码都一样，<b>负数的反码是对原码的除符号位外的其他位进行取反后的结果（取反即如果该位为0则变为1而该位為1则变为0操作）而补码是先求原码的反码，然后在反码的末尾位加1后得到结果，即补码是反码+1</b>

- 此时这个值是补码,需先转换成原码，原码再转换成真值;

- 因为是有符号的int8而非uint8,`1101 0000`第一位为1,即负号,

- 正数的补码是自身(正数的反码补码原码都一样),负数的补码是原码的反码+1;

- 将该补码转换为原码,转为原码后再转为真值;

> 1 101 0000  
> 负数是除符号位之外取反然后 +1,<br>
> `1 010 1111 + 1 `得<br>
> `1 011 0000`,即<br>
> -(2^5 + 2^4)

得到 -48

[更多可参见](https://www.cnblogs.com/myseries/p/5204878.html9)

注: 此篇最开始有一处错误,即1表示负,0表示正;

更多可搜索`计算机补码的规则`
[或可点击](https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fr=aladdin)

更多为何负数用补码表示而不直接用原码表示,[可点此](https://www.cnblogs.com/dingyingsi/p/6075967.html)
以及[此文](https://www.cnblogs.com/pauline/p/7573208.html)